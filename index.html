<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuzikun.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="今天珍惜今天">
<meta property="og:type" content="website">
<meta property="og:title" content="小徐的Blog">
<meta property="og:url" content="http://xuzikun.com/index.html">
<meta property="og:site_name" content="小徐的Blog">
<meta property="og:description" content="今天珍惜今天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="小徐">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xuzikun.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>小徐的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="小徐的Blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小徐的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuzikun.com/2022/11/13/helloworld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="小徐">
      <meta itemprop="description" content="今天珍惜今天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小徐的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/13/helloworld/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 16:51:26" itemprop="dateCreated datePublished" datetime="2022-11-13T16:51:26+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 23:15:17" itemprop="dateModified" datetime="2022-11-14T23:15:17+08:00">2022-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="欢迎你">欢迎你！</h1>
<p>虽然现在这里还是<strong style="color:#00b0f0;">冷冷清清</strong>，</p>
<p>但是之后我会建起一片<strong style="color:#00b050;">茂密的森林</strong>！</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuzikun.com/2022/11/15/%E3%80%8AA%20comprehensive%20survey%20of%20LIDAR-based%203D%20object%20detection%20methods%20with%20deep%20learning%20for%20autonomous%20driving%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="小徐">
      <meta itemprop="description" content="今天珍惜今天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小徐的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/%E3%80%8AA%20comprehensive%20survey%20of%20LIDAR-based%203D%20object%20detection%20methods%20with%20deep%20learning%20for%20autonomous%20driving%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《A comprehensive survey of LIDAR-based 3D object detection methods with deep learning for autonomous driving》读书笔记</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 10:20:04 / 修改时间：10:41:01" itemprop="dateCreated datePublished" datetime="2022-11-15T10:20:04+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3D-Detection/" itemprop="url" rel="index"><span itemprop="name">3D-Detection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="a-comprehensive-survey-of-lidar-based-3d-object-detection-methods-with-deep-learning-for-autonomous-driving-基于lidar的自动驾驶深度学习3d物体检测方法的综合调查-读书笔记">《A
comprehensive survey of LIDAR-based 3D object detection methods with
deep learning for autonomous driving》
（《基于LIDAR的自动驾驶深度学习3D物体检测方法的综合调查》
）读书笔记</h1>
<p>[TOC]</p>
<h2 id="section1-引言">Section1 引言</h2>
<p>与摄像头相比，LiDAR不受光照条件的限制，而且以无隐私的方式捕获数据，这使得它们在技术和道德方面都非常适合复杂的户外环境。这篇文章关注的是：<strong>基于LiDAR的3D目标检测器（仅使用LiDAR传感器数据，而不依赖任何其他传感器的数据）</strong></p>
<p>针对点云中的3D目标检测及其在自动驾驶中的应用已有大量研究，其他综述类文献侧重于<strong>自动驾驶应用中的目标检测和语义分割，以及使用多模态技术的深度学习网络。</strong></p>
<p><em>与前述工作相比，该综述的贡献总结如下：</em></p>
<p><em>1.文章介绍了一个<strong>通用操作流程</strong>，为<strong>结构化分类</strong>奠定基础，便于比较并显示<strong>各检测器间的相似之处和不同之处。</strong></em></p>
<p><em>2.文章提供了详尽的<strong>最新3D目标检测器列表</strong>。侧重于描述每种目标检测器的<strong>优缺点</strong>和其在<strong>操作流程上的特殊性</strong>，以确保检测结果的高效性和有效性。</em></p>
<p>3.文章最终的结论确定了未来新的3D目标检测器设计中<strong>应该采用或避免的一些关键特征</strong>。</p>
<h2 id="section-2-背景">Section 2 背景</h2>
<h3 id="激光雷达和点云">2.1 激光雷达和点云</h3>
<p>LiDAR的最终输出是一组点，称为点云。每个点通常是一个<strong>四维向量编码</strong>，包含3D坐标[x,y,z]和激光反射强度r，激光反射强度会反应有关物体反射表面的信息。某些LiDAR会用<strong>五维向量</strong>对每个点进行编码，增加一个值e——对应于<strong>激光脉冲超出其标准宽度的伸长率</strong>。</p>
<p>LiDAR坐标系中每个点的3D坐标计算如下：</p>
<p><span class="math display">\[ x = d * cos(\omega) * cos(\phi)
\]</span></p>
<p><span class="math display">\[ y = d * cos(\omega) * sin(\phi)
\]</span></p>
<p><span class="math display">\[ z = d * sin(\omega)  \]</span></p>
<p>其中：</p>
<p>d 指的是测量距离</p>
<p>φ 指绕Z轴的偏航角</p>
<p>ω 指每个激光发射器的固定俯仰角</p>
<h3 id="d-bbox-编码">2.2 3D BBox 编码</h3>
<p><strong>3D BBox(A three-dimensional bounding
box，三维边界框)用于定义目标在3D空间中的位置、大小和方向。</strong>3D
BBox具有适当的尺寸和方向来与目标紧密绑定。如果目标被部分遮挡或截断，3D
BBox调整适当的大小和位置以表示完整目标的大小。对自动驾驶而言，<strong>会假设所有物体都在地面上</strong>，那么仅需要对<strong>偏航角</strong>进行预测。<strong>3D
BBox由其3D中心坐标[x,y,z]、尺寸[l,w,h]和偏航方向θ进行编码。</strong></p>
<h2 id="section-3-操作流程"><strong>Section 3 操作流程</strong></h2>
<p>文章提出一个基于LiDAR的3D目标检测器共通的操作流程，<strong>由三个不同的模块组成：</strong></p>
<p><strong>1.LiDAR</strong> <strong>SDR</strong>（LiDAR Sensor Data
Representation LiDAR数据的表达形式）<strong>、</strong></p>
<p><strong>2.特征提取（Feature extraction）、</strong></p>
<p><strong>3.核心目标检测</strong>。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151039417.png" alt="image-20221114224142246" style="zoom: 67%;" /></p>
<p>如上图所示，</p>
<ol type="1">
<li>在<strong>LiDAR SDR</strong>中，输入的LiDAR点云数据被转换为<span
style="background:#FFFFBB;">结构化且紧凑</span>的表达形式；</li>
<li>在<strong>特征提取</strong>中，上述表达形式可被提取出<span
style="background:#FFFFBB;">丰富的高维特征</span>；</li>
<li><strong>核心目标检测</strong>模块则负责处理<span
style="background:#FFFFBB;">学习到的高维特征，输出目标类别、位置、大小的预测结果</span>。</li>
</ol>
<p>核心目标检测模块由两个阶段组成：检测器网络（Detector
Networks）和预测细化（Prediction
Reﬁnement）。检测器网络接收来自特征提取模块的高维特征作为输入，并输出关于目标的类别、位置和大小的
3D BBox候选框。预测细化对检测器网络中的3D
BBox进行重新采样，提取局部特征并对其进行处理，以输出对目标位置、大小和类别最终更准确的预测。</p>
<p>在核心目标检测模块中仅使用检测器网络的3D目标检测器被称为一阶段（One-stage）检测器，检测器网络和预测细化阶段均被使用的检测器则被称为二阶段（two-stage）检测器。一阶段<strong>检测器在推理时速度快但精度稍逊，二阶段检测器精度高但速度慢。</strong></p>
<p>更详细的介绍如下</p>
<h3 id="lidar-sdr">3.1 LiDAR SDR</h3>
<p>输入的LiDAR数据以点云形式来表示（可来自一个或多个LiDAR传感器，根据车上安装的数量而定）。但是由于点云非结构化和非固定大小的特征，它不能直接被3D目标检测器处理，必须通过某种表达形式将其编码为更紧凑的结构，目前主要有以下五种表达形式：<strong>基于点的（point-based）、基于体素的（voxel-based）、基于支柱特征的（pillar-based）、基于投影的（projection-based）和基于图的（graph-based）</strong>。最新的检测器架构中还会用两种不同的表达形式，称之为双重表达类别。</p>
<h4 id="point-based"><strong>3.1.1 Point-based</strong></h4>
<p>输入的LIDAR点云数据保留了点云的非结构化形式，但当转换为固定大小时，其会变得更加紧凑。</p>
<p>通过随机采样和最远点采样（Furthest Point
Sampling，FPS）这两种不同的方法将点云从其原始大小（即大约120k点）采样到较小的固定大小的N点（即N=16k点）来实现的。</p>
<p>在随机抽样中，会随机抽取点直到选择至N个点为止。但随机抽样存在偏差：相较于点云稀疏区域的点，点云较密区域的点会被更频繁地采样。</p>
<p>FPS算法通过迭代过程根据最远距离标准来选择点，可以减轻这种偏差。在每次迭代中，FPS会<strong>先计算未采样点到点集合（第一个点随机采样，第二个点为距离第一个点最远的点）的最小距离</strong>，然后选择距离最远的未采样点，如此循环往复，最终得到的结果是一个更具代表性的点云，<strong>但这种方式会增加计算成本。</strong></p>
<h4 id="voxel-based-体素化"><strong>3.1.2 Voxel-based
体素化</strong></h4>
<p>体素化是将点分配给体素的过程，给定一个传入的LiDAR点云<span
class="math inline">\(P= {p1,p2,...,pN}\)</span> 和3D 空间 [<em>L,</em>
<em>W, H</em>] ，以此划分固定大小的体素[<em>uL, uW, uH</em>]。</p>
<p>根据<strong>笛卡尔坐标系或圆柱坐标系</strong>对3D空间进行分区，分别产生长方体或圆柱切片形状的体素。按照圆柱坐标系的体素化也被称为混合柱面（Hybrid-Cylindrical-Spherical
，HCS）体素化。</p>
<p>如果没有点被分配给这一体素，该体素则被确定为<strong>零体素</strong>，当至少有一个点分配给它时，则将其确定为<strong>非零体素</strong>。</p>
<p>执行点到体素分配/映射的方式有三种：<strong>固定体素化（fixed
voxelization）、动态体素化（dynamic
voxelization）和混合比例体素化（hybrid scale
voxelization）。</strong></p>
<p><strong>固定体素化</strong>：含两个阶段：<strong>分组阶段和采样阶段</strong>。</p>
<p>分组阶段：首先，构建一个大小为<span class="math inline">\(V\times O
\times
F\)</span>的固定缓冲区，其中V是体素的最大数量，O是每个体素的最大点数，F是特征向量的大小。在分组阶段，所有点
<span class="math inline">\(p_i\)</span>
根据它们的3D坐标会被分配给体素<span
class="math inline">\(V_j\)</span>。</p>
<p>采样阶段：鉴于存在一个体素包含的点数可能多于O个的情况，采样阶段会从体素中随机子采样O个点。假设点数为K，其中(K&lt;O)），则将K个点分配给一个体素，然后在剩余的(O-K)缓冲区索引上应用零填充。</p>
<p>以上方式同样适用于体素。假设非零体素的总数为T，其中(T &gt;
V)，则随机对体素进行子采样，否则，如果(T &lt; V)，则对剩余的 (V - T)
缓冲区索引。</p>
<p><strong>动态体素化：</strong>在动态体素化中，点到体素的分配策略类似于固定体素化的分组阶段，其中所有点都分配给体素。</p>
<p>然而，与固定体素化不同的是，没有采样阶段，因此不会预先确定3D空间中非零体素的最大数量V和每个体素的最大点数O，这两个数字而是动态变化的。这会产生一个<strong>动态缓冲区</strong>且<strong>不会丢失任何信息</strong>，因为没有体素或点被丢弃。</p>
<figure>
<img
src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040185.png"
alt="image-20221115100705122" />
<figcaption aria-hidden="true">image-20221115100705122</figcaption>
</figure>
<p><span class="math inline">\(F_V (p_i)\)</span>是将每个点 pi
分配给体素 vj 的映射函数</p>
<p><span class="math inline">\(F_P (v_j)\)</span>是在体素 vj 内收集
pi点的映射函数</p>
<p><strong>混合比例体素化：</strong>与动态体素化类似，3D空间中非零体素的最大数量V[L,W,H]和每个体素的最大点数O不是预先确定的，而是动态变化的。然而，<strong>仅确定了点到体素的映射函数</strong>，因此没有建立双向映射。此外，给定一个differ<span
class="math inline">\([u^s_L,u^s_W,u^s_H]\)</span>的总数，其中s∈{1,2,...,S}，即<span
class="math inline">\(S=2,u^1_L=u^1_W=0.1m,u^2_L=u^2_W=0.2m\)</span>。在某些论文中，体素的高度对于所有比例都是固定的。点到体素映射通过一个索引ci确定，公式如下：</p>
<figure>
<img
src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040930.png"
alt="image-20221115100732674" />
<figcaption aria-hidden="true">image-20221115100732674</figcaption>
</figure>
<p>前文提到的固定体素化、动态体素化和混合比例体素化都是根据3D坐标将点分配给体素，在空间域中来变换LiDAR点云。为了完成整个体素化过程，下一步是通过<strong>提取体素特征</strong>来转换特征域中的点云。</p>
<p>提取体素特征有以下几种方式：</p>
<p>①二进制占用编码（最简单的方式），其中二进制值0和1分别分配给每个零和非零体素；</p>
<p>②统计方法，例如统计3D坐标、反射强度的平均值，甚至是形状因子；</p>
<p>③深度学习模型。首先，使用标准坐标、反射强度值和其他基于统计的特征来对各个点进行编码。接下来，将点引入基于PointNet的架构中，从而产生输出特征向量。这种架构最具代表性的例子是体素特征编码（Voxel
Feature Encoding，VFE）模块，如图3所示。</p>
<figure>
<img
src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040107.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<center>
VoxelNet 的VFE模块框图
</center>
<h4 id="pillar-based基于柱的"><strong>3.1.3
Pillar-based基于柱的</strong></h4>
<p>根据《Pointpillars: Fast encoders for obPject detection from point
clouds.》一文介绍，Pillar-based这种点云表达形式<strong>忽略了沿Z轴的划分</strong>，3D空间<span
class="math inline">\([L,W,H]\)</span>划分为固定大小的柱子<span
class="math inline">\([uL,uW,H]\)</span>。直观来讲，柱子被视为沿Z轴的未绑定体素。与体素化类似，将点分配给柱子是通过固定体素化、动态体素化和混合比例体素化三种不同的方式进行的。</p>
<p>Pillar-based的特征的提取是通过深度学习模型，该模型受遵循VFE模块的Point
Net启发而来。由于柱子没有沿Z轴划分，Pillar-based的点云表达形式被视为多通道的BEV图像。Point
Pillars这种目标检测器提出了Pillar-based
表达形式下的点云的特征提取这一过程中最具代表性的模块。</p>
<h4 id="projection-based-基于投影的"><strong>3.1.4 Projection-based
基于投影的</strong></h4>
<p>在Projection-based的点云表达形式中，3D空间的点通过透视变换的方式被投影到2D平面中。基于投影的点云表达形式分为前视图(FV)和鸟瞰图(BEV)。</p>
<p><strong>前视图（Front-View
projection，FV）</strong>：点云被投影到一个球形或圆柱形表面，其原点位于LiDAR传感器。然后将圆球或圆柱的表面展开成2D平面，最终形成密集且结构化的距离图像。</p>
<p>初始特征的数量取决于FV
距离图像中的通道数。前视图中的像素通常由手工或预定特征进行编码，例如二进制占用编码、3D
坐标、与传感器的距离、方位角或其对应点的反射强度等。</p>
<p><strong>鸟瞰图（Bird’s Eye View
，BEV）</strong>：通过将点分配给相应的网格（一个网格可能包含多个点），将点云投影到具有一定网格分辨率的λ米的BEV地图中。</p>
<p>与前视图相似，BEV图像的通道数决定了初始特征的数量。BEV图像中的网格/像素通常是手工或根据预定特征进行编码，例如沿
Z 轴固定大小分区的二进制占用编码和网格内点的统计值。</p>
<p>在Graph-based的表达形式中，<strong>点云被转换为图形</strong>。<strong>点被视为节点</strong>，<strong>一个点与其位于固定半径d内的其他点相连后被视为边。</strong></p>
<p>在原始点云的基础上使用该方法来计算非常低效，因此<strong>常用体素化后的采样点云来代替原始点云</strong>。</p>
<p>每个节点的初始特征的计算方式与中类似。首先，选择节点周围半径d内的一组点。通过多层感知器(MLP)处理其规范坐标和反射强度值，之后通过Max-pooling操作计算节点的初始特征向量。</p>
<h3 id="特征提取">3.2 特征提取</h3>
<p>被转换为结构化且紧凑的表达形式后，在特征提取模块可使用某些技术和架构来提取丰富的高维特征。这些技术主要分有两大类，<strong>3DBN</strong>(3D
Backbone Networks)和<strong>2DBN</strong>(2D Backbone Networks
)。选择何种特征提取技术会受到LiDAR
SDR形式的影响，例如将点云投影到BEV中后只能用2DBN来进行高维特征提取，不可用3DBN。</p>
<h4 id="d-backbone-networks"><strong>3.2.1. 3D Backbone
networks</strong></h4>
<p>根据构建模块的不同，主要有三组不同的3DBNs。</p>
<ol type="1">
<li>第一组是在3D空间中运行的3D CNN(Convolutional Neural Networks,
卷积神经网络)，</li>
<li>第二组是Point-Net/PointNet++网络，</li>
<li>第三组是GNN(Graph Neural Networks,图神经网络)。</li>
</ol>
<p><strong>3DBN
CNN：</strong>3D卷积应用于3D空间中的结构化数据，例如用于自动驾驶应用的体素化点云等。但3D卷积的<strong>计算负担</strong>导致其无法保证实时性，进而阻碍了3D
CNN在自动驾驶应用中的使用。研究者们进一步设计了<strong>空间稀疏卷积和子流形稀疏卷积网络</strong>以有效加速卷积操作，因此构建了3D稀疏(3D
SpConv)和3D子流形稀疏(3D Sub-SpConv)卷积网络模型。无独有偶，文章《Voting
for voting in online point cloud object detection》的研究者演示了一种在
3D 数据中应用滑动窗口（sliding window）的有效投票方案（voting
scheme)。</p>
<p>[^其实在Transfomer的论文里面，作者也提到了这样的背景，就是CNN计算负载过大，人们想了很多办法来优化它，比如3D稀疏(3D
SpConv)和3D子流形稀疏(3D
Sub-SpConv)卷积网络模型，但是transfomer的作者最后骄傲的说，虽然做了这些改进，但是问题还是没有解决，但是transfomer就没有这个问题。之后可以去看一下基于transfomer
的 DERT]:</p>
<p>考虑到LiDAR点云的<strong>稀疏性</strong>（即大约90%的体素都没有点），Vote3
Deep使用了<strong>投票方案</strong>（voting scheme），而SECOND使用了3D
SpConv和3D SubSpConv来构建基于3D sparse
CNN的骨干网络，用于LiDAR点云中的3D目标检测。</p>
<p>3DBN sparse
CNN的设计遵循encoder网络架构或encoder/decoder网络架构。Encoder网络架构会使用足够多的连续的3D
SpConv层和3D SubSpConv，然后是Batch
Normalization和Relu。<strong>输出一个缩小的、具有丰富特征的体素化3D空间</strong>。随后，执行高度压缩以沿Z轴连接特征并构建高维BEV特征图。encoder/decoder网络架构与encoder网络架构相同，而对于encoder部分，使用足够多的连续的3DSpConv层和3DSubSpConv，然后是Batch
Normalization和Relu，最终结果是一个与初始空间维度相似的上采样体素化3D空间，每个体素会被分配一个语义标签。encoder和encoder/decoder
3D CNN架构的框图如图4所示。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040503.webp" alt="img" style="zoom: 50%;" /></p>
<center>
两种不同 3DBN CNN 架构的框图：(a) 3D sparse CNN encoder，如SECOND； (b)
3D sparse CNN encoder/decoder，如 Parts A2 Net
</center>
<p><strong><em>3DBN
PointNet++：</em></strong>点云输入后，PointNet++的分割形式能够<strong>提取每个点的语义分割分数</strong>和<strong>全局的上下文特征</strong>。因此，PointNet++非常适合从LiDAR点云中提取特征。</p>
<p>在其语义形式中，PointNet++由几个遵循encoder网络架构的SA(Set
Abstraction，集合抽象)层和几个遵循decoder网络架构的FP(Feature
Propagation,
特征传播)层组成。给定初始数量的点作为质心，SA层利用FPS算法在球查询区域内（围绕质心点）选择固定数量的点，然后应用PointNet提取局部特征向量。SA层学习到的特征输入至FP层后，FP层通过插值将学习到的多尺度特征传播回所有点。许多自动驾驶领域的3D目标检测器使用都PointNet++作为3DBN来进行特征提取。</p>
<p>为了节省计算资源，研究者们尝试移除FP层。部分论文提出了仅使用PointNet++的encoder网络架构部分。但同时为了弥补decoder部分的不足，PointNet++的SA层中引入了一种新的点采样算法，称为融合采样（Fusion
Sampling,
FS）。FS是一种采样策略，它使用两种采样算法，FPS和Feature-FPS(F-FPS)。F-FPS计算每个SA层末端的点之间的特征距离，并将其用作选择点的标准，以尝试增加前景点的选择而不是背景点。FS样本的点一半是基于欧几里得距离（FPS），另一半基于特征距离（F-FPS），并试图在两种FPS算法之间找到平衡。用于3D目标检测的语义3DBN
PointNet++ 和encoder/decoder 和3DBN PointNet++ encoder
的FS的框图如下。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040191.webp" alt="img" style="zoom:33%;" /></p>
<center>
两种不同 Backbone 3D PointNet++ 架构的框图： (a) 类似于 STD 的 3D
PointNet++ 编码器/解码器。 (b) 3D PointNet++ 编码器架构，具有 3DSSD
中的融合采样
</center>
<p><strong>3DBN
Graph:</strong>输入Graph-based的点云表达形式，GNN用于通过沿边缘聚合特征来学习每个节点的特征。GNN会执行固定数量的T次迭代，其中第t次迭代的节点特征用作第(t+1)次迭代的输入特征。MLP（多层感知机）和Max操作用于提取类似于PointNet的节点特征。MLP的权重不在迭代之间共享，而是在每次迭代<span
class="math inline">\(t=[1,2,.,T]\)</span>时单独学习。</p>
<h4 id="d-backbone-networks-1"><strong>3.2.2 2D Backbone
networks</strong></h4>
<p>2DBN是一种全连接卷积网络 (Fully Convolutional Network，FCN)，应用于
2D 空间中的结构化数据（如BEV 和 FV
距离图像）来提取丰富的高维特征图。</p>
<p>2DBN有不同的架构，大致可分为以下四类：FPN(Feature Pyramid
Networks，特征金字塔网络)、U-Net、ResNet和VGG。</p>
<p>其中对于遵循 FPN 架构的 2DBN，输入和输出特征图的数量并不总是相同的。
因此引入以下术语：</p>
<ul>
<li>SISO：单输入，单输出（Single Input feature map, Single Output
feature map）</li>
<li>SIMO：单输入，多输出（Single Input feature map, Multiple Output
feature maps）</li>
<li>MIMO：多输入，多输出（Multiple Input feature maps, Multiple Output
feature maps）</li>
<li>MISO：多输入，单输出（Multiple Input feature maps, Single Output
feature map）</li>
</ul>
<p>2DBN的构建块通常由2D卷积(2D Conv)层以及Batch
Normalization和Relu组成，然而，对于某些3D目标检测器，2D Deformable(2D
DefConv)或2D Dilated Convolutions(2D DilConv))也适用。2D转置卷积(2D
TrConv)用于对特征图进行上采样。</p>
<p>下图2DBN最具代表性的几个架构。遵循BEV(FPN
SISO)架构的2DBN会执行上采样到固定大小，然后进行连接，以构建高维BEV特征图，VoxelNet和SECOND检测器采用的这类2DBN；遵循FV（FPN
SISO）架构的2DBN用于提取与输入空间维度相同的高维FV特征图像，RangeRCNN检测器采用的这类2DBN。遵循BEV（FPN
MIMO）架构的2DBN被用以提取多尺度的高维BEV特征图，分为早期和晚期融合阶段，Voxel-FPNto检测器采用的这类2DBN。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040344.webp" alt="img" style="zoom:50%;" /></p>
<center>
三种不同 2DBN 的框图： (a) BEV (FPN SISO) 架构，如VoxelNet、SECOND。 (b)
FV (FPN SISO) 架构，如 RangeR-CNN。 (c) BEV (FPN MIMO) 架构，如Voxel-FPN
</center>
<h3 id="核心目标检测">3.3 核心目标检测</h3>
<p>核心目标检测模块用于处理从特征提取模块中提取的<strong>高维特征</strong>，并以<strong>3D
BBox</strong>的形式提供关于目标类别以及检测目标的<strong>位置和大小的分类置信度分数和回归值</strong>。它分为两个阶段，<strong>检测器网络和预测细化。</strong></p>
<h4 id="检测器网络"><strong>3.3.1 检测器网络</strong></h4>
<p>检测器网络有两种主要方法：<strong>Anchor-based
和Anchor-free</strong>。</p>
<p>Anchor-based网络利用多个<strong>预定义大小的锚点</strong>来搜索高维特征图，输出分类分数，并相对于锚点的位置和大小回归目标的位置和大小。</p>
<p>Anchor-free网络不使用预定义的锚，而是利用来自特征提取模块的二进制标签信息来识别属于目标的点或区域/部分。
然后对于目标的每个点或部分，进行目标预测，包括一个类置信度分数和一个 3D
BBox。</p>
<p><strong>Anchor-Based 网络</strong>：Anchor-Based
网络最具代表性的架构是RPN（Region Proposal Network
，候选框提取网络）。在3D目标检测器中，RPN接收一个或多个高维BEV特征图作为输入，输出目标的类别、3D位置、大小和方向等。研究会使用预定好的固定大小的3D锚点框。锚框大小是根据每个类的自然维度来选择的，例如KITTI数据集中对于“汽车”类，会用l(长)=3.9m、w（宽）=1.6m、h（高）=1.56m的锚尺寸，而对于“行人”类，则使用l=0.8m、w=0.6m、h=1.73m的锚点尺寸。</p>
<p>输入高维BEV特征图之后，高效的1x1卷积层被应用于每个目标任务的分类、目标位置/大小和方向的检测，从而产生概率得分和回归图。RPN的输出是多个3D
BBox候选框，一般会存在多个候选框重叠并对应于同一个目标的情况。为去除多余的3D
BBox候选框，NMS（Non Maximum
Suppression，非最大抑制）则被用作后处理步骤。</p>
<p>另一种方法（不在BEV中操作）在3D空间中引入了球形锚的概念。对于每个点，会创建一个具有预定尺寸的球形锚，并应用NMS来减少锚的总数。之后在每个球形锚点上用一个PointNet网络来预测一个3D
BBox。最后，会使用一个额外的NMS来删除冗余的3D Bbox候选框。</p>
<p><strong>Anchor-Free 网络：</strong>Anchor-Free
网络利用特征提取模块中的二进制标签信息来识别目标点(部分)，并预测每个点(部分)的3DBBox候选框。Anchor-Free
网络分为在3D空间运行和在2D空间中运行。</p>
<p>对于在3D空间中运行的Anchor-Free
网络，一个常见的趋势是为特征提取模块中的每个点学习二进制语义标签（背景/前景）。然后，通过全连接(FC)层对每个点进行3D
BBox预测。对于所有上述Anchor-Free
网络，每个目标（由众多前景点/体素组成）可能会被计算出多个候选框，因此，仍然需要NMS来去除冗余的3DBBox候选框。为了完全去除NMS后处理步骤，文章《Joint
3D instance segmentation and object detection for autonomous
driving.》中采用的方法是将每个点的二进制语义信息以及每个点的空间嵌入（SE）信息（均从3DBN学习得到）提供给一个简单的聚类算法（即K-means）来执行实例分割，因此每个实例只生成一个3DBBox候选框。</p>
<p>在2D空间中运行的Anchor-Free
网络，当试图利用每个前景网格的内部对象位置时，《Object as hotspots: An
anchor-free 3D object detection approach via firing of
hotspots》这篇文章中预测了两个单独的BEV图，一个用于前景分类，一个用于3DBBox回归，每个前景根据对应于目标分区的k类进一步编码。</p>
<p>受2D图像中2D Anchor-free目标检测器Center
Net的启发，研究者们将相同的概念扩展到3D目标检测器，提出了通过将3D目标视为BEV中的中心点的方法。</p>
<p>《PIXOR: Real-time 3D Object Detection from Point
Clouds》这篇文章使用了Anchor-free方法，目标在BEV中被视为2D BBoxes。</p>
<p><strong>所有上述在2D空间中运行的Anchor-Free
网络中，均遵循FCN架构。</strong>2DBN的输出BEV特征图通过共享或并行的FCN模块进行处理，用于分类、BBox回归等。每个FCN块由连续的2DConv层组成。然后，对于每个任务，应用1x1卷积来生成置信度分数和BBox回归图。在《Afdet:
anchor free one stage 3D object
detection》文章的方法中，不再需要NMS后处理步骤，对于每个目标，仅预测一个中心点，因此仅会生成一个3D
BBox候选框，这会节省计算资源。</p>
<h4 id="预测细化"><strong>3.3.2 预测细化</strong></h4>
<p>二阶段检测器会使用预测细化(PR)这一步骤。从检测器网络接收的3D
BBox候选框是PR的输入，之后PR在细粒度级别对其进行采样并提取特征以提高分类置信度得分和明确3D
BBox位置、大小和方向。PR分为两大类，在3D空间中运行和在2D空间中运行。在3D空间中运行的PR根据表达形式上又会进一步分为三个子类别，即基于点的（point-based）、基于图形的（graph-based）和基于体素的（voxel-based）。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151040108.webp" alt="img" style="zoom: 25%;" /></p>
<center>
预测细化的子类别
</center>
<p><strong>3D point-based PR</strong>利用点云的自然表达形式，从3D
BBox候选框中采样固定数量的点。这种方式根据点的规范坐标、反射强度和学习的前景分数对点进行编码，而其他架构采用的是点与传感器的距离和学习的全局上下文特征对点进行编码。这些点之后被引入PointNet或PointNet++架构，以改进类置信度分数和3D
BBox。</p>
<p><strong>3D graph-based
PR</strong>由两个模块组成：一个用于提取每个候选框/目标的局部特征（R-GCN），另一个用于提取每帧的全局特征（C-GCN）。R-GCN模块对3D
BBox候选框进行采样，并对点进行特征编码。接下来给定选定的点，通过MRGCN层构建和处理图像以输出局部特征向量。C-GCN模块构建一个图，其中每个候选框/目标都被视为一个点，并使用从R-GCN学习的局部特征向量进行编码。然后，通过EdgeConv层处理该图，以学习所有候选框的全局特征。对于每个候选框，将来自C-GCN的全局特征与来自R-GCN的局部特征连接，然后引入两个完全连接的层以细化类置信度分数和3D
BBox。</p>
<h2 id="section4-各类检测器的分析综述">Section4
各类检测器的分析综述</h2>
<p>本部分讲述了48类最新的3D目标检测器，对其操作流程中每一个模块所用方式均进行了详细介绍、整理及分析，如下表所示。根据点云表达形式将其分为基于点的（35-42）、体素化的（
1-24）、基于柱的（
25-29）、基于投影的（30-34）、基于图像的（43）、双重表达形式（44-48）</p>
<figure>
<img
src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211150941360.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="section-5-数据集和评估指标"><strong>Section 5
数据集和评估指标</strong></h2>
<p>公开可用的数据集可通过3D
BBox的详细标签来训练基于LiDAR的3D目标检测器。</p>
<p>这些数据集有：①来自卡尔斯鲁厄理工学院的KITTI和最新的KITTI-360数据集、②来自nuTonomy的nuScenes数据集、③来自Waymo的Waymo开放数据集、④来自奥迪的A2D2数据集、⑤来自百度公司的Apollo
Scape数据集、⑥来自本田研究院的H3D数据集、⑦来自LyftInc.的Lyft数据集。上述数据集在某些属性上有所不同，例如标注目标的数量和目标类别等，但所有数据集都包含LiDAR传感器数据以及标注好的3D
BBoxes。下面介绍了三个（①②③）具有在线3D和BEV基准的开放数据集及其评估指标。</p>
<h3 id="kitti-数据集">5.1 KITTI 数据集</h3>
<p>KITTI数据集是最古老的自动驾驶应用数据集之一，由卡尔斯鲁厄理工学院和芝加哥丰田技术学院创建。它记录了德国卡尔斯鲁厄市白天的高速公路和农村地区的数据。数据集中包含：从两个正面高分辨率立体摄像系统（一种颜色和一种灰度）捕获的图像、从安装在汽车顶部的Velodyne
HDL-64E
LiDAR传感器捕获的360°点云以及定位数据。KITTI以每秒10帧(fps)的速率提供具有LiDAR点云图像的同步数据。</p>
<p>一个点由来自LiDAR传感器的3D坐标及其反射强度值的四维向量[x,y,z,r]编码。</p>
<p>对于3D和BEV目标检测任务，KITTI数据集提供了一个固定的训练和测试集。目标被标记为八种不同的类别，但只有其中三个（汽车、行人和自行车）会被用于评估。此外，只有在相机视野内的物体（在图像中可见）才会用于评估。每个目标都以3D
BBox的形式被标记，并由其中心坐标[x,y,z]、长、宽、高[l,w,h]（以米为单位）、航向和观察角度[α、θ]（以弧度为单位），遮挡和截断状态、对应类别等信息组成。目标最终会被分为简单、中等或困难类别，具体取决于其在2D图像中的相应大小（以像素为单位）及其截断状态。</p>
<p>对于3D和BEV目标检测任务，KITTI使用均值平均精度(mAP)作为度量，并在联合交集(IoU)上有一个阈值。“汽车”类的IoU阈值设置为0.7，“行人”和“自行车”类的IoU阈值设置为0.5。3D目标检测任务会使用预测值和地面实况3D
BBoxes之间的3D IoU；BEV目标检测任务会使用预测值和地面实况BEV
BBoxes之间的2D IoU。如果IoU高于阈值，则将预测视为算法预测正确(True
Positive，TP)，否则视为算法预测错误(False
Positive<strong>，</strong>FP)。</p>
<p>精确率(p)是指所有预测正确值TP(NTP)占所有预测值（<em>NTotalDetections，</em>包括TP和FP）的分数，即所有预测为正样本的样本中有多少是真正的正样本，计算公式为:</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151014636.png" alt="image-20221115101412582" style="zoom:33%;" /></p>
<p>召回率 (r) 是指所有预测正确值 TP (NTP ) 占所有真值 (NGroundTruth )
的分数：</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151014315.png" alt="image-20221115101435274" style="zoom:33%;" /></p>
<p>Precision-Recall (P-R) 曲线是通过绘制不同 IoU
阈值的精确率和召回率（分别在 y 轴和 x 轴上）构建。</p>
<p>平均精度（Average Precision
）是由P-R曲线形成的面积。KITTI使用基于11个召回率点计算P-R曲线的mAP，在2019年第三季度后，改为使用40个召回率点插值，以更好地逼近P-R曲线。</p>
<p>平均精度(mAP)的计算方式是对所有类的平均精度(AP)进行平均来计算的。然而，该度量不能定义方向相似性（3D
BBox的前、后部是否正确）。因此，KITTI还引入了平均方向相似度(AOS)，定义为：</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151014973.png" alt="image-20221115101450929" style="zoom:33%;" /></p>
<p>其中N是召回点的数量（2019年第三季度前为11，之后为40），K是召回子集（为[0/11，1/11，2/11，...，11/11]和2019年第三季度之后是[0/40,1/40,2/40,...,40/40]</p>
<p>方向相似度 s ∈ [0, 1] 是归一化余弦相似度，定义为：</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151015670.png" alt="image-20221115101519625" style="zoom:33%;" /></p>
<p>其中D(r)是在召回率r下所有目标检测的集合，是第i个检测的预测方向与地面实况方向之间的角度差，如果检测i是TP，则δi设置为1，否则δi设置为0.</p>
<h3 id="nuscenes-数据集">5.2 NuScenes 数据集</h3>
<p>由NuTonomy（新加坡企业）创建的NuScenes数据集是一个新推出的数据集，在波士顿和新加坡的四个不同地区在各种照明和天气条件下捕获的数据，可用于自动驾驶应用程序。它提供来自32束LiDAR传感器的LiDAR点云数据、来自5个不同radar传感器的radar数据以及来自六个不同RGB相机的相机数据。传感器放置在汽车相应位置上可覆盖360°视野。</p>
<p>此外，激光雷达和摄像头传感器可以很好地同步，以提供LiDAR数据、radar数据和RGB图像之间的数据对齐（具体时间同步文章可查看知乎文章：<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/453871235">自动驾驶中的时间同步(上) -
知乎
(zhihu.com)</a>）。标记数据以2Hz的速率提供，但中间传感器帧也以高达20Hz的速率释放。</p>
<p>NuScenes共有23个不同的目标类，但是它们之间存在严重的类不平衡。每个目标都用其类、属性（可见性、活动、姿势）和一个由其中心坐标[x,y,z]、长度、宽度、高度[l,w,h]及其偏航角θ编码的3DBBox进行标注。</p>
<p>对于3D目标检测任务，模型在23个类别中的10个类别中进行评估。引入了一个标量分数，即nuScenes检测分数(NDS)，由以下等式给出：</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151015778.png" alt="image-20221115101549726" style="zoom:33%;" /></p>
<p>AP是指基于地平面上的2D中心距离d的匹配（超过0.5、1.2和4m阈值），而不是常用的重叠比(IoU)。AP的计算为P-R曲线下的归一化区域，但是精度或召回率低于10%的点会被丢弃以降低噪声的影响。给定一组类别C和一组阈值距离值D={0.5,1,2,4}，mAP计算如下：</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151016178.png" alt="image-20221115101600114" style="zoom:33%;" /></p>
<p>算法预测正确（TP）的计算指标：如果一个预测的中心距离是位于BEV中相应地面实况3D
BBox中心的d=2m距离阈值内，则该预测被视为TP。TP指标均为本地单位，还有一些指标被用于计算真阳性，包括：</p>
<ul>
<li>平均平移误差（ATE），即欧式中心距，单位为BEV，单位为m</li>
<li>平均尺度误差（ASE），它是方向和对齐后的3D
IoU差异，计算方式为（1-IoU）</li>
<li>平均方向误差(AOE)，即预测与地面实况之间的最小偏航角差，单位为弧度</li>
<li>平均速度误差（AVE），它是绝对速度误差，作为BEV中速度差的L2范数，单位为m/s</li>
<li>平均属性误差(AAE)，表示为1减去属性分类准确度，(1-acc)</li>
</ul>
<p>对于某些指标没有意义的某些类别（例如障碍和锥体的AVE、AOE和AAE指标），这些指标不予考虑。平均真阳性(mTP)指标计算公式为：</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151016753.png" alt="image-20221115101611711" style="zoom:33%;" /></p>
<h3 id="waymo-开放数据集">5.3 Waymo 开放数据集</h3>
<p>Waymo开放数据集(WOD)是最新发布的自动驾驶数据集之一。它包括从4个短程LiDAR和1个中程LiDAR捕获的LiDAR数据以及从5个高分辨率RGB相机捕获的相机数据。该数据集非常多样化，因为它是一天中的不同时间在旧金山、山景城和凤凰城的郊区和城市地区所记录得到。在传感器和坐标系之间提供高质量的校准和转换。</p>
<p>LiDAR数据以距离图像的表达形式提供。每个距离图像覆盖汽车周围的360°视野。距离图像中的像素对应于LiDAR返回，并使用其距离、强度、伸长率、无标签区域、LiDAR到相机投影信息以及捕获LiDAR点时的车辆姿态进行编码。“无标签区域”是指LiDAR点位于标签忽略的区域中。</p>
<p>对于3D目标检测任务，汽车周围75m半径内的目标会以3D边界框的形式标记为四个类别：车辆、行人、自行车、标志。每个3DBBox由其中心坐标[x,y,z]、长、宽、高[l,w,h]（以米为单位）、航向角θ（以弧度为单位）和其唯一的跟踪ID进行编码。</p>
<p>WOD也使用常用的AP指标。然而，与KITTI用于计算AP的40点插值方法不同，WOD将AP计算为P-R曲线下的面积</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151016278.png" alt="image-20221115101646232" style="zoom:33%;" /></p>
<p>其中p(r)是P-R曲线。</p>
<p>除了平均精度(AP)指标外，WOD还引入了平均精度航向(APH)指标（用以包括航向信息）。与AP类似，APH指标计算如下</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151017640.png" alt="image-20221115101707586" style="zoom:33%;" /></p>
<p>其中h(r)的计算类似于p(r)，方法是通过航向精度min对每个真阳性进行加权。</p>
<p>关于检测3D目标的难度，WOD定义了两个不同的级别，即LEVEL 1和LEVEL
2。LEVEL
2中分配的目标被认为是最难检测的目标。首先，所有无LiDAR点的目标会被忽略，不会分配到任一级别。其次，若一个目标的LiDAR点少于6个，或者如果人工标注员手动将目标分配给该类别，则该目标被分配到LEVEL2。然后将其余目标分配给LEVEL1。</p>
<p>为了实验的一致性，Waymo团队为训练、验证和测试提供了固定的数据集。</p>
<h2 id="section-6-讨论"><strong>Section 6 讨论</strong></h2>
<p>在本节中，将介绍每一类目标检测器的发现和关键见解，会考虑到这些目标检测器的操作流程、检测性能和效率。与第4节所定义的一样，这部分的分类依据是其输入的LiDAR
SDR。</p>
<p>检测性能由第5节中详述的评估指标衡量。尽管这些指标可能略有不同（取决于数据集），<strong>侧重于测量在3D空间和BEV中检测目标类别的精度和召回率</strong>。根据每个数据集报告的推理时间评估效率。为了清楚起见，还说明了用于评估检测器的GPU硬件。</p>
<p>KITTI、nuScenes和Waymo数据集的性能评估结果分别在表2、表3和表4-5中所示。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211150949345.jpeg" alt="img" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211150959707.webp" alt="img" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211150959836.webp" alt="img" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211150950791.webp" alt="img" style="zoom:80%;" /></p>
<p>总之，在本文比较研究中，对于给定的数据集，<strong>没有一个3D目标检测器在各个目标类别中都优于其他目标检测器</strong>。某些检测器在检测“汽车”类上表现更好，而其他检测器在检测“行人”或“自行车”类别上表现更好。此外，本文针对KITTI数据集评估了大多数检测器的性能（nuScenes和Waymo尚未公开），这部分解释了2019年之前的3D目标检测器。</p>
<p>仅在KITTI上评估且仅针对“汽车”类的最新3D目标检测器进行评估，这不利于全方位评价整体性能和有效性，但由于许多3D目标检测器公开提供其源代码（如表7所示），可以通过评估
KITTI 数据集的其余类以及其他可用数据集（如 nuScenes 和
Waymo）的方法，可进一步了解方法的有效性。</p>
<p><img src="https://gitee.com/easonxu01/blogimg/raw/master/img/202211151004986.webp" alt="img" style="zoom: 33%;" /></p>
<p>接下来，研究基于依赖于输入LiDAR
SDR的分类为每一类方法提供详细的性能分析。</p>
<h3 id="voxel-based-目标检测器">6.1 Voxel-based 目标检测器</h3>
<p>从section
4中给出3D目标检测器的图表中，可以看到，在大多数方法中，体素特征的提取大多会通过VFE模块及其变体或体素内点的平均值来进行。很少使用二进制占用值和手工制作的体素特征（通常是较旧的方法会使用）。体素化的数据通常由SECOND及其变体提出的3DBN处理。</p>
<p><strong>在3DBN模块之后，基于体素的目标检测器将数据表达形式从3D转换为2D，从而产生BEV。该策略在提高3D目标检测性能和缩短推理时间之间实现了平衡。</strong>仅使用3DBN模块的方法会有不错的检测性能，但推理时间很高，而仅使用2DBN的架构在BEV会兼具低推理时间和更高的检测性能。关于由BEV特征图馈送的相应2DBN，文献中最常用的架构是FPN，其变化主要与输入和输出特征图的数量有关。</p>
<p>检测器网络上，与Anchor-based
RPN相比，基于体素的检测器更倾向于使用Anchor-free网络，由于其计算高效的结构以及缺乏为每个目标类别定义和微调锚点大小。</p>
<p>根据section
4中对操作流程的分析，显示正好有一半的3D目标检测器在点云表达形式中使用的是基于体素的。最新的方法已经提出了许多不同的架构，实现了大多数据集和目标类的最先进或顶级检测性能。上述三种方法中的共同策略是通过预测目标的部分或判别点及其目标内空间位置，对目标的3D几何信息进行有效编码。如表2所示，大多数基于体素的目标检测器是一阶段段检测器，这表明单次推理通过导致可接受的性能以及低推理时间。还有使用任一体素的两阶段检测器或基于点的网络来提取目标3D形状的细粒度表示并细化预测的3D
BBox。结果，在略微增加的推理时间下观察到改进的检测性能。然而，最近的检测器在其第二阶段提出了一种基于混合体素/点的网络，既保持了一阶段检测器的低推理时间，又实现了顶级性能。</p>
<h3 id="pillar-based-目标检测器">6.2 Pillar-based 目标检测器</h3>
<p>在Pillar-based
3D目标检测器中，柱（pillar）的特征完全通过基于点的网络提取，如VFE模块及其变体。接下来，采用BEV特征图的构建，这为使用2DBN模块奠定了基础。这部分所有的目标检测器中，2DBN模块都由FPN架构组成，其变化主要与输入和输出特征图的数量有关。大多数方法使用Anchor-based
RPN 进行目标检测。同时，与Voxel-based
目标检测器相似的是，为了效率和简单性，也存在Anchor-Free
网络的趋势。此外，<strong>所有Pillar-based的目标检测器都是一阶段检测器</strong>。</p>
<p>与所有方法相比，Pillar-based
目标检测器在KITTI数据集中所有“简单”和“中等”级别的目标类别上均取得了不错的检测性能，但在“困难”级别上略逊一筹。此外，在更复杂和要求更高的nuScenes和Waymo数据集中，Pillar-based检测器的性能比Voxel-based检测器效果较差，即使对于“简单”和“中等”的情况也是如此。</p>
<p>研究认为这是因为不能有效编码目标的3D结构和几何信息，尤其是在远处或被遮挡的情况下。原因可能是Point-based网络的局限性，即用于提取柱特征向量的轻量级VFE，以及缺乏3DBN模块的原因。</p>
<p>通过比较Point
Pillars和SECOND在KITTI和Waymo数据集中的性能来论证这一假设。两者结构相似，主要区别在于：Point
Pillars使用轻量级VFE模块来提取柱状特征并构建BEV特征图，SECOND通过3DBN构建BEV特征图。结果发现，Point
Pillars在KITTI数据集上的性能略有提高，但SECOND在Waymo数据集上的性能大大优于Point
Pillars。</p>
<p><strong>就计算效率而言，Pillar-based
检测器是最有效的检测器，因为与其他类检测器相比，他们实现了最低的推理时间。</strong></p>
<h3 id="projection-in-bev-目标检测器">6.3. Projection in BEV
目标检测器</h3>
<p>对Projection in BEV
3D目标检测器而言，其采用手工制作的特征来构建BEV特征图，并在架构的其余部分使用典型的2D目标检测架构，例如Faster-RCNN，主要2DBN的架构中有些不同。</p>
<p>事实表明，这一类别表现出总体上降低的检测性能以及增加的推理时间。此外，Pillar-based
3D目标检测器出现以来，这一类别对研究界的使用吸引力降低。</p>
<h3 id="projection-in-fv目标检测器">6.4. Projection in FV目标检测器</h3>
<p>对于Projection in FV
3D目标检测器，距离图像像素编码方式采用手工制作的特征，然后引入2DBN进行特征提取。这个类别中只有两种方法：LaserNet和Range-RCNN。</p>
<p>这两种方法仅在KITTI数据集的“汽车”类中进行评估，其中一种仅用于BEV检测任务。这类方式的推理时间很短，但这一特定类别并没有充分激发研究界的兴趣。造成这种情况的一个潜在原因是FV距离图像无法反映物体的真实比例。为了解决这个问题，Range-RCNN在FV距离图像中执行特征提取后，后续预测细化部分中它对检测部分的BEV图进行了对应。</p>
<h3 id="point-based-目标检测器">6.5. Point-based 目标检测器</h3>
<p>Point-based
3D目标检测器仅在3D空间中运行，它们主要使用encoder/decoder架构的PointNet++作为其3DBN模块。与学习到的高维特征点一起，执行前景/背景点分割。该分割信息用于指导Anchor-Free网络，以输出每个点的目标候选框。大多数Point-based
3D目标检测器由两个阶段组成，其中大多数在第二阶段遵循Point-based
的点云表达形式。但事实证明在预测细化的第二阶段使用voxel-based的表达形式可提高检测性能并减少推理时间。相反，使用graph-based的点云表达形式的观察结果为检测性能的边际增加以及推理时间的显著增加。</p>
<p>最近一种一阶段检测器引入了PointNet++
encoder架构的新3DBN模块，在检测性能和计算效率方面产生了一种简化且整体更有前景的结构，可与顶级的voxel-based
检测器相媲美。</p>
<p>如表2所示，大多数point-based
检测器略微适用于实时应用。由于这个限制，最近有文章研究了该类检测器的改进。特别是3D
SSD目标检测器采用了高效的3DBN并已在nuScenes和数据集中进行了评估。而StarNet目标检测器通过处理感兴趣区域而不是立刻处理点云来弥补point-based
检测器的缺点，这一检测器也在Waymo中进行了评估。</p>
<h3 id="graph-based-目标检测器">6.6 Graph-based 目标检测器</h3>
<p>对于Graph-based
目标检测器，文献中只报道了一项——Point-GNN。这种方法一旦构建了点云的图表示，就会连续应用图神经网络，且在不使用其他模块（如3DBN、2DBN等）的情况下进行端到端的Graph-based
的目标检测。</p>
<p>如表2所示，KITTI数据集所报告的Point-GNN的需要花费的高推理时间可能是其吸引力降低的主要原因，尤其是对于自动驾驶这种对推理时间要求较高的应用而言。但从检测性能非常令人满意且总体上很有希望而言，可以看出Graph-based检测器的研究潜力。</p>
<h3 id="双重点云表达目标检测器">6.7 双重点云表达目标检测器</h3>
<p>双重点云表达形式的目标检测器存在两种方法。</p>
<p>第一种方法，构建两个不同的点云表达形式以提取依赖于视图的特征，然后将其融合从而产生逐点的多视图特征表示。</p>
<p>第二种方法，第一个点云表达形式（即voxel-
based）用于提取多尺度特征向量和3D
BBox候选框，第二个点云表达形式（即point-based）用于进一步处理和聚合多尺度体素特征向量到少量关键点以辅助3D
BBox细化。双重点云表达目标检测器不遵循与其架构有关的特定模式，而是基于其点云表达形式使用相应的操作模块，如3DBN/2DBN等。</p>
<p>这两种方法都旨在更有效地学习和编码目标的3D结构信息。学习多视图特征的第一种方法可以整体提高检测性能，但是与学习多尺度特征的第二种方法相比较差差，因为PV-RCNN
v1、PV-RCNN
v2的检测器实现了最先进的检测性能，适用于KITTI和Waymo数据集中的大多数课程和难度级别。与voxel-based
检测器相比，所有双重点云表达检测器的推理时间（Waymo的PV-RCNN
v1除外）略有增加，但仍适用于实时应用。</p>
<h3 id="注意力机制">6.8 注意力机制</h3>
<p><strong>注意力（attention）或自我注意(self
attention)可提高3D目标检测器的整体性能。</strong>特别是TA-Net中的工作实现了三重注意（TA）模块用以在提取柱特征向量期间进行局部注意。</p>
<p>为了在特征向量中提供全局attention，为3D目标检测器实现了自关注模块。attention模块在两个不同的网络下实现，即完全自我注意（Full
Self Attention ，FSA）和可变形自我注意（Deformable Self Attention
，DSA），它们可以插入现有的3D目标检测器中提高其整体性能。这种改进已在Point-Pillars、SECOND、Point-RCNN、PV-RCNNv1中得到证明。</p>
<h2 id="section-7.未来研究趋势和未解决问题">Section
7.未来研究趋势和未解决问题</h2>
<p>本节们将介绍对3D
目标检测在自动驾驶应用中的未来趋势、研究潜力和对未解决问题的见解。</p>
<h3 id="在嵌入式系统中的应用">7.1 在嵌入式系统中的应用</h3>
<p>大多数文献报告了以上检测器对GPU硬件（通常在台式计算机中）的推理时间，在嵌入式系统中的边缘计算设备情况容易被忽略。但嵌入式系统是自动驾驶汽车或移动机器人必不可少的硬件。此外，很少有文献报道这些方法在网络大小和内存分配方面的复杂性。</p>
<p>某些检测器（如Pillar-based检测器）专注于通过采用简单高效的架构来对嵌入式系统进行计算友好，从而减少网络参数的数量，或者通过专门设计的GPU推理库（如英伟达的Tensor
RT）进一步优化其架构。然而，这两种方法也并没有在边缘计算设备上进行测试或评估。此外，这些方法的能耗（嵌入式系统最重要的因素之一，尤其是对于自动驾驶汽车和移动机器人）从未被视为关键约束或作为基准报告。受《Deep
learning inference at the edge for mobile and aerial
robotics》一文中在Nvidia Jetson
TX1上对用于语义分割推理的深度学习方法进行了比较研究和基准测试。受其启发，《Energy-aware
design of vision-based autonomous tracking and landing of a
uav》一文也根据检测器在Nvidia Jetson
Nano上的服务质量功能作为深度学习2D目标检测器的能耗评估。类似的用于嵌入式系统中基于LiDAR的3D目标检测器的比较和能量分析研究具有较大的研究潜力，如表7所示的公开可用的检测器代码将进一步有助于实现这一研究尝试。</p>
<h3 id="迈向高效的混合网络">7.2 迈向高效的混合网络</h3>
<p>PV-RCNNv2和Voxel-RCNN工作的最新进展专注于用更高效的体素启发式来替代point-based网络中某些计算成本高昂的操作（例如PointNet++中的集合抽象和球查询操作），同时仍保留point-based网络的其余部分不变。这样的解决方案促使混合网络的出现，其充分利用了两者优点：提高检测性能和缩短推理时间。类似的方法也可以应用于图神经网络，以减少图神经网络的计算负担。因此，识别现有架构中计算效率低下的瓶颈并通过混合方法改进这一方面存在研究潜力。</p>
<p>大多数3D目标检测器使用单个的点云表达，最近一些方法使用双重点云表达来提取更丰富和更具辨别力的特征向量。在同一检测器中使用更多点云表达的唯一限制是架构的推理时间。混合网络旨在进一步减少检测器的推理时间，这有助于使用额外的第三个甚至第四个点云表达来学习更多的判别特征。</p>
<h3 id="lidar-点云的稀疏性">7.3 LiDAR 点云的稀疏性</h3>
<p>点云固有的稀疏性引起了研究界的兴趣，特别是对于3D目标补全和形状生成架构。在用于自动驾驶的3D目标检测中，目标和形状补全技术已被用作训练期间的预处理步骤，以通过域适应策略关联和学习稳健的特征。然而，在LiDAR点云的推理过程中，3D目标检测器尚未使用目标补全和形状生成架构，这可能会提高检测性能。</p>
<h3 id="自监督学习">7.4 自监督学习</h3>
<p>在WS3D的工作中，现有的二阶段目标检测器（即Point-RCNN）被用作实现和测试弱监督训练方法的主干。研究者手动构建弱注释数据并将它们用于训练检测器的第一阶段，而详细的标注数据用于训练第二阶段。到目前为止，这项工作是自动驾驶应用中基于LiDAR的3D目标检测器的自我监督学习最接近的近似值。由于难以获得详细的标注数据，3D目标检测器的自监督和半监督学习具有很大的研究潜力。</p>
<h3 id="复杂现实场景的性能评估">7.5 复杂现实场景的性能评估</h3>
<p>目前所提出的3D目标检测器只是在三个公开可用数据集（即KITTI、nuScenes和Waymo）中的一个或多个场景中进行评估。然而，与更复杂和更现实的3D目标检测场景相比，这三个数据集以及表1中显示的其余数据集都表现出局限性。这些限制包括场景多样性的降低、噪声数据的缺乏和目标类别的数量少。</p>
<p><strong>场景多样性：</strong>所有公开可用的数据集都包含来自城市或高速公路区域的场景，<strong>这些场景几乎是平坦的</strong>，具有边缘地面倾斜度。因此，所有3D目标检测器旨在为每个物体预测4个自由度(Degrees
of Freedom ，DoF)的3D
BBox姿势，它代表x、y、z位置和偏航角方向。对于自动驾驶中更具挑战性的3D目标检测案例，必须包括“<strong>目标并不总是与自车在同一平面内</strong>”的场景，即在具有不同地面倾斜度的交叉道路的情况。这样的场景在城市和农村都可能出现。在这种苛刻的场景中，当前对4-DoF姿态的3D
BBox预测可能不足，因此可能导致3D目标检测器将预测的姿态从4-DoF扩展到5-DoF，包括3D
BBox的俯仰角。</p>
<p><strong>噪声数据：雾、雨和雪等不利天气条件</strong>是在激光雷达传感器测量中引入额外噪声的主要自然现象，因为在这种天气条件下激光雷达传感器发射的激光束可能会发生折射。然而，nuScenes和Waymo数据集已部分解决了基准数据集中出现的此类噪声。除自然现象外，<strong>多个激光雷达传感器同时发射也可能会引入额外的干扰噪声</strong>。这不是指单个车辆的多个LiDAR传感器（自车安装的LiDAR传感器配置是已知的），而是指场景中的其他车辆也使用LiDAR传感器。目前所有公开可用的数据集都在自车是唯一安装了LiDAR传感器/传感器的场景中记录的。因此，上述情况下LiDAR传感器测量中可能会引入额外的噪声。恶劣的天气条件和来自其他LiDAR传感器的干扰都会引出对补偿噪声数据的研究，即通过某些预处理算法在将点云送至现有3D目标检测器之前过滤掉噪声数据。</p>
<p><strong>数据集目标类别：</strong>当前标准测试数据集针对一定数量的目标类别评估3D目标检测器的性能。对于大多数据集，目标类的数量为三个，nuScenes包含十类。在现实场景中，要检测的目标类别的数量可能会进一步增加以反映真实的上下文。此外，数据集的类分布不均匀会导致训练过程中出现类不平衡问题，随着目标类数量的增加，这种问题变得非常严重。MEGVII检测器解决了nuScenes数据集的类别不平衡问题。然而，更有效的策略研究仍有研究潜力，特别是对于那些使用Anchor-Free
网络的策略。此外，迁移学习还可用于重新训练3D目标检测器以适应新的目标类别，基于少量且类别平衡的标记数据。这种策略也可以与自我监督学习结合使用。</p>
<h2 id="section-8-结论">Section 8 结论</h2>
<p>在过去几年中，由于深度学习架构、可用LiDAR的进步及其在自动驾驶商业应用中的潜力。仅使用LiDAR点云数据的3D目标检测已成为一个活跃的研究领域。</p>
<p>本文对基于LiDAR的3D目标检测器的操作流程进行了分析，并通过统一的框架展示和讨论了各操作模块，以建立各检测器间的共同点。检测器通过上述统一框架进行分类和单独呈现。此外，根据自动驾驶应用的三个开放数据集的标准和评估指标来研究检测器性能。总结了研究发现和构成未来工作研究潜力的关键要素。这项工作是目前文献中最完整的，旨在为每种方法的优缺点提供有用的见解。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小徐"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">小徐</p>
  <div class="site-description" itemprop="description">今天珍惜今天</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Easonxu-01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Easonxu-01" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1021013634@qq.com" title="E-Mail → 1021013634@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/7306237358" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7306237358" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-11 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小徐</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共14.7k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  



  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/clicklove.js"></script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":125,"height":250},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>


